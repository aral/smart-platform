#!/usr/bin/env perl

use strict;
use warnings;

use RSP;
use IO::Dir;
use Proc::Pidfile;
use File::Path qw();
use File::Copy qw();
use File::Spec;
use Git::Wrapper;

$0 = "keymanagerd";

my $timeout = RSP->config->{keymanager}->{timeout} || 10;
my $keytmp  = RSP->config->{keymanager}->{keydir};
my $conf    = RSP->config->{gitosis};
File::Path::mkpath( $keytmp );


if ( fork() ) {
  exit;
}

## don't have more than one running
my $pp = Proc::Pidfile->new;

my $gw = Git::Wrapper->new( $conf->{admin} );

## handle sighup to get new configurations
$SIG{HUP} = sub {
  print "Re-loading configs\n";
  $keytmp  = RSP->config->{keymanager}->{keydir};
  $conf    = RSP->config->{gitosis};
  $timeout = RSP->config->{keymanager}->{timeout} || 10;
  $gw      = Git::Wrapper->new( $conf->{admin} );
  File::Path::mkpath( $keytmp );
};

while( 1 ) {
  my $dh = IO::Dir->new( $keytmp );
  if ( !$dh ) {
    RSP::Error->throw("couldn't read from $keytmp: $!");
  }
  my @files = grep { $_ !~ /^\./ } $dh->read();
  if (@files) {
    foreach my $file (@files) {
      my $origin = File::Spec->catfile( $keytmp, $file );
      my $dest   = File::Spec->catfile( $gw->dir, 'keydir', $file );
      ## first copy the key
      if ( File::Copy::copy( $origin, $dest . ".tmp") ) {
	## if we can copy it into the keydir, then we move it to the correct
	## name, this makes the filesystem operation atomic, with the assumption
	## that this final move is within the filesystem.
	File::Copy::move( $dest.".tmp", $dest );
	## then we unlink it.
	unlink( $origin );
      }
      ## add the file to the git staging area
      $gw->add('keydir/'.$file);
    }
    ## commit the changes, and push.
    $gw->commit({ all => 1, message => "added keys: " . join("\n\t", @files)});
    $gw->push();
  }
  $dh->close();
  ## every ten seconds we check for new keys
  select(undef, undef, undef, $timeout);
}

undef $pp;
